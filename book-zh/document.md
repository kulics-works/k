# Feel 编程语言

Feel 是一个专注于效率的开源编程语言，它可以帮你轻松构建跨平台软件。

通过精心设计的语法规则，这门语言可以有效降低读写负担，让你能够把真正的注意力放在解决问题上。  

## 关键特性

- 容易分辨、现代化的语法。
- 自动管理内存。
- 泛型。
- 多范式编程。
- 跨平台。
- Unicode。

## 目录

1. [安装与使用](#安装与使用)
1. [基础语法](#基础语法)
1. [基础类型](#基础类型)
1. [操作符](#操作符)
1. [选择结构](#选择结构)
1. [循环结构](#循环结构)
1. [函数](#函数)
1. [数据类型](#数据类型)
1. [泛型数据类型](#泛型数据类型)
1. [数组类型](#数组类型)
1. [泛型函数](#泛型函数)

## 安装与使用

目前 `Feel` 支持编译到 `JVM`，因此需要在系统中安装 `JVM` 环境。  

执行编译器就会扫描当前文件夹的 `.feel` 文件，并且自动转译为同名的目标文件。  

下载:

- [JVM](https://github.com/kulics-works/feel-jvm)

## 基础语法

### 基本语句

在 Feel 内，语句是最小的组成单位。

语句的基本形式如下。

```feel
let a = 0;
let b = 1;
```

一个语句通常以显式的分号结尾。但如果这个语句以 `}` 和换行结尾，我们可以选择省略分号。

例如：

```feel
let a = { 1 + 1 + 1
        + 1 + 1 }
let b = 1;
```

### 入口函数

我们需要定义一个入口来让程序知道从哪里启动，我们可以通过 main 函数声明。

```feel
let main() = {}
```

这里我们声明了一个名称为 main 的函数，`=` 右边是这个函数的返回值，`{}` 表示这个函数什么也不执行。

关于函数的更多细节将在之后的章节中说明。

### 显示信息

现在让我们的程序输出一些内容看看，我们可以使用 `printLine` 函数向控制台打印一些信息。

```feel
let main() = printLine("Hello, world!");
```

现在尝试执行这个程序，我们可以看到控制台上显示了 `Hello, world!`。

### 注释

注释只用来向使用者提供额外的信息，并不会被真正编译到可执行的程序中。

例如：
```
## 行注释

#*
    块
    注释
*#
```

### 变量

Feel 的变量是一种绑定语义，相当于是把一个变量名和一个值绑定在一起，从而建立起了关联关系，类似于键值对。为了安全性的考虑，Feel 的变量默认是不可以改变的，当然 Feel 也提供了另一种变量——可变变量。

#### 只读变量

在 Feel 中是通过 let 关键字来声明只读变量的，变量遵循先声明后使用的原则。

Feel 通过静态类型确保类型安全，变量绑定可以在声明时显式通过 `: type` 标注类型，在上下文中有足够的信息时，我们也可以省略类型，编译器回从上下文中推断出变量的类型。

示例代码如下：

```feel
let a: Int = 5; ## 显式标注类型
let b = 123; ## 自动推断类型
```

一旦只读变量被声明之后，它的类型和值在当前作用域内就不会再被改变。

如果我们尝试对只读变量赋值，编译器会报错。

```feel
let a = 5;
a = 6; ## 错误
```

#### 可变变量

如果我们需要一个可以被重新赋值的变量，可以使用可变变量声明。

在 Feel 中通过 let mut 关键字来声明可变变量，同样遵循先声明后使用的原则。

示例代码如下：

```feel
let mut a: Int = 5; ## 显式标注类型
let mut b = 123; ## 自动推断类型
```

### 赋值

对于可变变量，我们可以在需要的时候多次改变它的值。

Feel 的赋值语句与大多数语言一样，都使用 `=` 声明，`=` 左边必须是可以被赋值的变量，程序会将 `=` 右边的值赋值给左边的变量。

示例代码如下：

```feel
let mut a = 0;
a = 1;
a = 2;
```

### 块表达式

在 Feel 中，`{}` 表示一个块表达式，块表达式可以包含一系列语句以及一个可选的最后一个表达式，块表达式的结果也是一个表达式。

块表达式中最后一个表达式的值就是块的值。如果没有最后一个表达式，那么块的值就是 Void。

通过块表达式可以组合一系列操作，比如多步初始化某个复杂的值。

```feel
let a: Void = {}
let b: Int = {
    let c = 7;
    let d = c + 14;
    (c + 3) * 5 + d / 3
}
```

### 标识符

标识符就是给变量、函数、结构体、接口等指定的名字。构成标识符的字母均有一定的规范，这门语言中标识符的命名规则如下：

1. 区分大小写，Myname 与 myname 是两个不同的标识符；
1. 类型和构造器只能使用大写声明，变量和函数只能使用小写声明。
1. 标识符首字符可以以下划线 `_` 或者字母开始，但不能是数字；
1. 标识符中其他字符可以是下划线 `_` 、字母或数字。
1. 在同一个 `{}` 内，不能重复定义相同名称的标识符。
1. 在不同 `{}` 内，可以定义重名的标识符，语言会优先选择当前范围内定义的标识符。

## 基础类型

我们只需要一些简单的基础类型，就可以开展大部分工作。

### Integer 整数

由于我们目前的计算机结构比较擅长计算整数，因此一个独立的整数类型有助于提升程序的运行效率。

在 Feel 中，默认的整数为 `Int` 类型，它可以表示有符号整数类型数据。

例如：

```feel
let i: Int = 3987349;
```

### Float 浮点数

整数不能满足我们对数字的需求，我们很多时候还需要处理小数。

在 Feel 中，默认的小数为 `Float` 类型，它可以表示浮点型数据。

例如：

```feel
let f1: Float = 855.544;
let f2: Float = 0.3141592653;
```

### Character 字符

计算机通常使用特定数字对字符进行编码显示，因此需要一种类型来表达字符，这个就是 `Char` 类型。

它只能是单个字符，只代表了某一个字符与数字的对应关系，所以即是字符，也是数字。

你只需要使用 `''` 包裹一个字符，它就会被识别为字符值。

例如：

```feel
let c1: Char = 'x';
let c2: Char = '8';
```

### String 字符串  

我们在并不是生活在一个只有数字的世界，所以我们也非常需要使用文字来显示我们需要的信息。

在本语言中，默认的文字为 `String` 类型，它是一个不限长度的字符串数据。

你只需要使用 `""` 包裹一段文字内容，它就会被识别为字符串值。

例如：

```feel
let s: String = "Hello, world!";
```

需要注意的是，字符串是由多个字符组成的类型，所以实际上字符串是一个固定顺序的列表，两者存在对应关系。很多时候我们可以像使用列表那样对字符串进行处理。

### Boolean 布尔

布尔指逻辑上的值，它们只能是真或者假。它经常用以辅助判断逻辑。

在本语言中，默认的布尔为 `Bool` 类型，它是一个只有 true 值和 false 值的类型。

例如：

```feel
let b1: Bool = true;
let b2: Bool = false;
```

## 操作符

操作符是一种告诉编译器执行特定的数学或逻辑操作的符号。

我们可以简单地理解成数学中的计算符号，但是编程语言有它不同的地方。

### 算术操作符

算数操作符主要被使用在数字类型的数据运算上，大部分声明符合数学中的预期。

例如：

```feel
let a = 4;
let b = 2;
printLine( a + b );    ## + 加
printLine( a - b );    ## - 减
printLine( a * b );    ## * 乘
printLine( a / b );    ## / 除
printLine( a % b );    ## % 取余，意思是整除后剩下的余数
```

### 比较操作符

比较操作符主要被使用在判断条件中，用来计算两个数据的关系，结果符合预期的为 `true`，不符合的为 `false`。

例如：

```feel
let a = 4;
let b = 2;
printLine( a == b );     ## == 等于
printLine( a != b );     ## != 不等于
printLine( a > b );      ## > 大于
printLine( a >= b );     ## >= 大于或等于
printLine( a < b );      ## < 小于
printLine( a <= b );     ## <= 小于或等于
```

### 逻辑操作符

逻辑操作符主要也被使用在判断条件中，用来进行逻辑运算（与、或、非）。

例如：

```feel
let a = true;
let b = false;
printLine( a & b );     ## 与，两者同时为真才为真
printLine( a | b );     ## 或，两者其中一者为真就为真
printLine( !a );        ## 非，布尔值取反
```

## 选择结构

选择结构用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。

在 Feel 中选择结构使用 if 语法表示，if 后面紧跟判断条件，在条件为 `true` 时执行 then 关键字后面的分支，在条件为 `false` 时执行 else 关键字后面的分支。

例如：

```feel
let main() = if 1 == 1 then printLine("yes") else printLine("no");
```

执行上面的程序会看到 `yes`。

if 同样也是表达式，then 和 else 分支后面都必须是表达式，根据 if 的条件，if 表达式的值可能是 then 或 else 其中的一个。

因此上面那段程序我们也可以这样写，两种写法结果等价。

```feel
let main() = printLine(if 1 == 1 then "yes" else "no");
```

由于 if 本身也是表达式，因此 else 后面自然也可以接另外一个 if 表达式，这样我们就可以实现连续的条件判断。

```feel
let x = 0;
let y = if x > 0 then "bigger" else if x == 0 then "equal" else "less";
```

当我们不需要处理 else 分支时，可以使用 if-do 语法，do 后面必须是表达式。

```feel
let main() = if 1 == 1 do printLine("yes");
```

### 短路逻辑运算

在选择结构或循环结构的条件中，我们可以使用短路逻辑运算 `&&` 和 `||` 来组合逻辑。短路逻辑运算的可以跳过部分不必要的计算，以节省计算资源或避免副作用。

短路逻辑与用 `&&` 表示，当左侧的条件为 `false` 时，将会跳过右侧的条件计算。

```feel
let main() = {
    if false && f() do { ## 不会执行 f()
        ...
    }
}
```

短路逻辑或用 `||` 表示，当左侧的条件为 `true` 时，将会跳过右侧的条件计算。

```feel
let main() = {
    if true || f() do { ## 不会执行 f()
        ...
    }
}
```

## 循环结构

循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。

在 Feel 中循环结构使用 while 语法表示，while 后面紧跟判断条件，在条件为 `true` 时执行 do 关键字后面的分支，然后重新回到判断条件处进行判断进入下一轮循环，在条件为 `false` 结束循环。do 分支后面必须是表达式。

这种 while 语法是表达式。

例如：

```feel
let main() = {
    let mut i = 0;
    while i <= 10 do {
        printLine(i);
        i = i + 1
    }
}
```

执行以上程序会打印 0 到 10。

当我们需要在循环中主动退出循环时，可以使用 break 语句。程序会在执行到 break 时退出当前最近的一层循环。

```feel
let main() = {
    let mut i = 0;
    while true do {
        if i > 20 do break;
        printLine(i);
        i = i + 1
    }
}
```

执行以上程序会打印 0 到 20。

如果我们需要在循环中跳过某些轮，可以使用 continue 语句。程序会在执行到 continue 时跳过当前一轮循环，继续执行下一次循环。

```feel
let main() = {
    let mut i = 0;
    while i <= 10 do {
        if i % 2 == 0 do continue;
        printLine(i);
        i = i + 1
    }
}
```

执行以上程序会打印 0 到 10 之间的奇数。

## 函数

函数是用来完成特定任务的独立的代码块。

通常我们会将一系列需要重复使用的任务处理封装成为函数，方便在其它地方重复使用。

### 定义

之前我们已经见过了入口函数，它使用了固定名称 main 来定义。

当我们需要定义其它函数时，我们可以使用同样的语法定义其它名称的函数。

函数通过 let 关键字定义，函数的名字后面使用 `()` 表示这个函数接受的参数，括号后面是这个函数的返回类型。返回类型在上下文明确时可以省略，由编译器推断返回类型。

函数的 `=` 右边必须声明一个表达式，这个表达式的值就是函数的返回值。

```feel
let f1(): Int = 1;
let f2(a: Int) = a + 1;
```

### 调用

那么怎么使用这些定义好的函数呢？我们只需要在函数表达式后面使用 `()` 语法就可以调用函数，从而得到函数的返回值。

`()` 必须按函数定义的参数要求传入对应类型的参数。

```feel
let a = f1();
let b = f2(1);
```

### 参数

参数是函数执行时能够接收的数据，通过这些不同的参数我们就可以让函数输出不同的返回值。

比如我们可以实现一个平方函数，每次调用可以返回参数的平方值。

非常简单的，我们只需要使用 `参数名: 类型` 就可以声明参数。

```feel
let sqrt(x: Int) = x * x;
let a = sqrt(x); ## a == 4
```

sqrt 接收一个 Int 类型的参数 x，然后返回它的平方值。调用 sqrt 的时候我们需要给出对应 Int 类型的表达式，就可以完成调用。

如果我们需要多个参数，可以按顺序逐个声明它们，中间使用 `,` 分割。调用也需要按同样的顺序给出表达式。

```feel
let add(x: Int, y: Int) = x + y;
let a = add(1, 2); ## a == 3
```

### 函数类型

在 Feel 中，函数与 Int、Float 等类型一样，也是一种类型，同理函数也可以作为表达式使用。

函数的类型使用 `(T) -> R` 语法声明，函数定义一样需要声明参数类型和返回类型，与函数定义不同的是参数不需要参数名。

函数定义之后，这个函数名就可以作为表达式使用，可以赋值给其它变量或者作为参数和返回值。

函数类型的变量跟函数一样使用 `()` 语法调用。

```feel
let sqrt(x: Int) = x * x; ## sqrt: (Int) -> Int
let f: (Int) -> Int = sqrt;
let a = f(2); ## a == 4
```

例如这个特性，我们也可以定义函数类型的参数或者返回值。

```feel
let hello() = printLine("Hello, world!");
let run(f: () -> Void) = f();
let toRun() = run;

let main() = toRun()(hello);
```

执行上面的代码我们会看到 `Hello, world!`。

### Lambda 表达式

如上面那种方式先定义一个函数再传入使用有时候显得比较啰嗦，因为我们仅仅只是希望执行一小段功能而已，未必想定义一个函数提供给其它地方使用。

这时我们可以使用 Lambda 表达式 的语法来简化我们的代码。

Lambda 表达式与函数定义很相似，只是 `=` 换成了 `=>`，并且没有函数名和 let 关键字。

如下面的代码所示，f2 的值是一个 lambda，它们的类型与 f1 一样，语法上也非常相似，lambda 的同样需要声明参数和返回类型，并且需要一个表达式作为返回值。

```feel
let f1(x: Int): Int = x + 1; ## f1: (Int) -> Int
let f2 = (x: Int): Int => x + 1; ## f2: (Int) -> Int
let a = f1(1) + f2(1); ## a == 4
```

在我们的上下文中可以得知 lambda 的类型时，我们可以省略它的参数类型和返回类型。

```feel
let f: (Int) -> Int = (x) => x + 1;
```

## 数据类型

数据类型是由一系列具有相同类型或不同类型的数据构成的数据集合，它是一种复合数据类型。

显而易见，数据类型适合用来将不同数据包装到一起，形成一个新类型，便于操作复杂的数据。

### 定义

我们可以使用 `type` 关键字声明一个新数据类型，数据类型需要使用 `()` 声明它所拥有的成员变量，与函数的参数类似。

```feel
type Empty();
```

上面我们声明了一个名叫 Empty 的新数据类型，这个数据类型什么数据都不包含。

接下来让我们定义一些更有意义的数据类型试试。

```feel
type Point(x: Int, y: Int);
```

Point 是一个具有 x 和 y 两个成员变量的数据类型，它可以用来表示二维坐标系中的某一个点。这样我们就可以使用 Point 这个类型表示我们在坐标系中的数据，而不用总是使用两个独立的 Int 数据。

### 构造

那么我们怎么构造一个新的 Point 数据呢？

和函数类型类似，我们同样使用 `()` 语法来调用我们的构造器，就可以得到我们需要的数据。

```feel
let a: Point = Point(0, 0);
```

### 使用成员变量

现在我们已经有了一个 Point 数据，我们要怎么使用里面的 x 和 y 呢？

很简单，我们只需要使用 `.` 语法，就能访问它们了。

```feel
type Point(x: Int, y: Int);

let main() = {
    let a = Point(64, 128);
    printLine(a.x);
    printLine(a.y)
}
```

执行上面的程序，我们可以看到 64 和 128。

### 可变类型

成员变量与变量一样，默认都是只读的。所以我们不能对 Point 中的 x 和 y 再次赋值。如果我们尝试这么做，编译器会报错。

```feel
type Point(x: Int, y: Int);

let main() = {
    let a = Point(64, 28);
    a.x = 2 ## 错误
}
```

我们可以给类型标注 mut 关键字，这样它就在构造的时候就允许被构造为可变类型，然后我们就可以对可变类型中的成员变量进行赋值了。

构造可变类型的实例需要在构造语法的前面使用 mut 关键字标注。

成员变量的可变性是跟随类型的，与实例变量是否可变没有关系，所以我们即使声明了只读变量也可以修改可变成员变量。

```feel
type mut Point(x: Int, y: Int);

let main() = {
    let a: mut Point = mut Point(64, 128); ## `a` 不需要声明为 mut
    a.x = 2; ## ok
    a.y = 0 ## ok
}
```

当我们定义了一个可变类型，它可以作为可变类型使用，同时也可做为只读类型使用，这取决于我们在使用处是否使用 mut 关键字标注。

可变类型被设计为是只读类型的子类型，所以可变类型的实例可以赋值或传递给只读类型。当我们将一个可变类型转换为只读类型使用时，它仍然会指向原来的实例，所以可变类型实例的修改仍然会导致只读类型那边观察到变化。

```feel
type mut Point(x: Int, y: Int);

let main() = {
    let a: mut Point = mut Point(64, 128); 
    let b: Point = a; ## ok
    printLine(a.x); ## 64
    printLine(b.x); ## 64
    a.x = 128;
    printLine(a.x); ## 128
    printLine(b.x); ## 128
    b.x = 256; ## error
}
```

### 成员函数

除了成员变量以外，数据类型还可以定义成员函数。成员函数能让我们的类型直接提供丰富的功能，而不需要依赖外部函数。

定义成员函数很简单，在类型定义的后面使用 `with` 关键字，再声明一个包含成员函数的块即可。

```feel
type Rectangle(length: Int, width: Int) with {
    this.area(): Int = this.length * this.width;
}
```

如上面的代码展示的，我们定义了一个成员函数 `area`，它用来计算 Rectangle 的面积。

跟普通的函数定义有差别的是，成员函数不需要使用 `let` 开头，而且通常前面会带上 `this.`。它用来表示当前类型的实例参数。

也许你已经注意到，在成员函数中我们访问成员变量跟在外部访问成员变量类似，只是我们需要使用 `this` 来表示实例的变量名。

和成员变量的访问一样，我们只需要使用 `.` 语法，就能访问成员函数了。

```feel
let main() = {
    let r = Rectangle(2, 4);
    printLine(r.area())
}
```

执行上面的程序，我们可以看到 8。

成员函数的 this 默认是只读的，这意味着我们不能在成员函数中修改成员变量。如果我们需要修改，需要在 this 的前面加上 `mut` 修饰。`mut this` 表示当前的实例类型是可变类型，所以它可以修改成员变量，这同时也要求只有可变类型的实例能访问可变成员函数。

```feel
type mut Rectangle(length: Int, width: Int) with {
    mut this.setLength(l: Int): Void = this.length = l;
}

let main() = {
    let a: Rectangle = Rectangle(2, 4);
    a.setLength(4); ## 错误，a 不是 mut Rectangle，不能调用 mut 成员函数
    let b: mut Rectangle = mut Rectangle(2, 4);
    b.setLength(4); ## ok
}
```

除了包含 this 的成员函数以外，我们还可以定义不包含 this 的成员函数。

这一类函数不能使用实例访问，只能使用类型名称访问。它可以让我们定义一些与类型关联性很高的函数但不需要实例作为参数的函数。

```feel
type Point(x: Int, y: Int) with {
    default(): Point = Point(0, 0);
}

let main() = {
    let a = Point.default();
    printLine(a.x); ## 0
    printLine(a.y); ## 0
}
```

例如上面的例子，我们为 Point 定义一个构造默认值的成员函数。然后使用 `Point.default` 的方式调用了它。

## 泛型数据类型

让我们来想想这样一个场景，当我们想在函数的返回类型上返回两个值该怎么做？

对于简单的情况，我们可以定义出一个固定的类型来包装两个值。

```feel
type Pair(left: Int, right: Int);

let f(): Pair = Pair(1, 2);
```

但如果我们有很多不同的类型需要包装，以上这种方式就显得不够通用了。

我们需要一种能表示容纳任意类型的 Pair，我们可以借助泛型数据类型定义它。

泛型数据类型与数据类型的区别在于它需要额外声明类型参数，这些类型参数表示将来会由实际传入的类型替换，从而让成员变量或成员函数的类型可以在后续实例化的时候替换为具体的类型。

```feel
type (T1, T2)Pair(left: T1, right: T2);
```

如上代码所示，我们在 `Pair` 的左边用另一种参数的形式声明了 T1 和 T2 两个类型参数。

如果我们需要多个类型参数，可以按顺序逐个声明它们，中间使用 `,` 分割。调用也需要按同样的顺序给出实际类型。

和普通参数不一样的是，类型参数的标识符总是以大写字母开头，并且没有类型标注。

接下来我们看看如何构造泛型数据类型。

```feel
let main() = {
    lef a1: (Int, Int)Pair = (Int, Int)Pair(1, 2);
    ## a1.left: Int, a1.right: Int
    lef a2: (Bool, Bool)Pair = (Bool, Bool)Pair(true, false);
    ## a2.left: Bool, a2.right: Bool
    lef a3: (Int, String)Pair = (Int, String)Pair(1, "a");
    ## a3.left: Int, a3.right: String
}
```

如上代码所示，当我们使用泛型 Pair 的时候，需要在泛型参数的位置传入实际的类型。根据我们传入的类型不同，对应变量的 left 和 right 的类型也会有所不同。

这样我们就实现了一个足够通用的 Pair 类型，对于任意类型的两个值，我们都可以使用它来作为我们的返回类型，大大简化了我们需要定义的类型数量。

上面的代码写起来还是比较繁琐，实际上当上下文类型明确的时候，我们可以省略泛型类型构造时的类型参数。所以我们可以使用更简洁的方式来实现上面的功能。

就像下面的代码这样，它和上面的代码是等价的。

```feel
let main() = {
    lef a1 = Pair(1, 2);
    ## a1: (Int, Int)Pair
    lef a2 = Pair(true, false);
    ## a2: (Bool, Bool)Pair
    lef a3 = Pair(1, "a");
    ## a3: (Int, String)Pair
}
```

## 数组类型

数组是一种泛型的数据类型，它可以存储一组相同类型的数据元素，每个元素都有一个索引来表示它在数组中的位置。数组的长度是固定的，它可以通过索引快速访问任意元素。

我们使用 `(T)Array` 来表示数组类型，其中 `T` 可以是任意类型。

数组类型可以使用数组字面量(`[elem1, elem2, …]`)的方式来初始化，其中 `elem1` 和 `elem2` 表示对应位置的元素，不同的元素之间使用 (`,`) 分割，我们可以传入任何表达式，但所有的元素必须是相同的类型。 

```feel
let x: (Int)Array = [1, 2, 3, 4, 5];
```

如上面的代码所示，我们使用数组字面量语法创建了一个 `(Int)Array`，它的元素就像字面量表示的那样是 `1, 2, 3, 4, 5`。

除了这种列举元素的字面量以外，我们也可以用另一种创建一个指定大小和默认值的数组字面量(`[default; size]`)来构造，`default` 是默认值，`size` 是元素的个数。

```feel
let y: (Int)Array = [0; 3];
## y == [0, 0, 0]
```

我们可以使用数组的 `size` 成员函数来获取它的元素个数。

```feel
printLine(x.size()); ## 5
```

我们可以使用下标语法 `[index]` 的方式来访问指定索引的元素，`index` 只能是 `Int` 类型的值。下标的起始是 0，`[0]` 对应第一个元素，后续元素以此类推。

```feel
printLine(x[0]); ## 1
printLine(x[2]); ## 3
printLine(x[4]); ## 5
```

配合 `while` 语法，我们就可以对数组的元素实现遍历，就像下面的代码一样。

```feel
let main() = {
    let x = [1, 2, 3, 4, 5];
    let mut n = 0;
    let size = x.size();
    while n < size do {
        printLine(x[n]);
        n = n + 1;
    }
}
```

数组和其它类型一样，默认是只读的，这意味着我们不能修改它的元素。如果我们需要一个可以修改元素的数组，我们和其它类型一样，在构造时声明为 `mut`，这样我们就可以得到一个可变的数组。

对数组元素的修改和对成员变量进行赋值是类似的，只不过需要使用下标语法。

```feel
let main() = {
    let x: mut (Int)Array = mut [1, 2, 3, 4, 5];
    printLine(x[0]); ## 1
    x[0] = 5;
    printLine(x[0]); ## 5
}
```

如上面的代码所示，我们将 x 声明为可变的数组，然后就可以使用 `[index] = value` 的方式对指定下标的元素进行赋值。

## 泛型函数

现在我们已经拥有了强大的泛型数据类型，但我们还没有办法对一个任意类型的泛型类型实现功能，比如说合并任意两个相同类型的数组。

是的，我们需要具备泛型的函数才能实现它。

泛型函数和泛型类型很类似，都是在标识符的前面使用相同的语法定义泛型参数。

```feel
let (T)mergeArray(a: (T)Array, b: (T)Array) = {
    ...
}
```

如上代码所示，我们在 `mergeArray` 的左边用同样的泛型语法声明了 T 这个类型参数。

接下来我们看看如何调用泛型函数。

```feel
let main() = {
    let x = [1, 2, 3];
    let y = [4, 5, 6];
    let z = (Int)mergeArray(x, y);
    ## z == [1, 2, 3, 4, 5, 6]
}
```

如上代码所示，它跟普通的函数调用差不多，不同的只是在函数名的前面增加了类型参数，就像泛型数据类型的构造一样。

同样的道理，在上下文明确的时候，我们也可以省略类型参数，下面的代码等价于上面的代码。

```feel
let main() = {
    let x = [1, 2, 3];
    let y = [4, 5, 6];
    let z = mergeArray(x, y);
}
```
