## Grammar Overview

## Export Name Space
export demo;

## Import Name Space
import {
    System;
    System.Text;
    System.Threading.Tasks;
    . = IO.File; ## 可以隐藏元素使用内容
}

let main() = {
    ## Define, 一般情况下编译器会自动判断类型
    let string String = "10";
    let number Float = 1.2;
    let integer Int = 123;
    let boolean Bool = true;
    let smallFloat = (1.2).toFloat32(); ## basic obj convert

    ## Const
    let PI = 3.141592653;

    ## Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}";

    ## Array
    let array [Int]Array = arrayOf(1, 2, 3);
    let array2 [Int]Array = [1, 2, 3];

    ## List
    let list [Int]List = [1, 2, 3, 4, 5];
    print( list[0] ); ## 使用下标获取

    ## Map, 前面为 key，后面为 value
    let map [String, Bool]Map = [("1", false), ("2", true)];
    print( map["1"] ); ## 使用key获取

    ## Function
    let f(a Int) Int = a;

    ## Function with no params no return
    let do_something_void() Void = {
        do_something_a();
        do_something_b();
    }

    ## Full Function with params and return
    let do_something_with_params(x Int, y String) type(a Int, b String) = (x, y);

    ## Function type
    let f fn(x Int, y Int) Int = (x Int, y Int) Int -> x + y;
    let f fn(x Int, y Int) Int = (x, y) -> x + y;
    let f(x Int, y Int) Int = x + y;
    let f(x Int, y Int) = x + y;
    let g() Void = {}
    let g fn() Void = () -> {}

    ## Currying
    let add = (x Int) -> (y Int) -> x + y;
    let add fn(x Int) fn(y Int) Int = (x) -> (y) -> x + y;
    let add fn(x Int)(y Int) Int = x -> y -> x + y;
    let add(x Int)(y Int) = x + y;
    let v = add(1)(2);

    ## Lambda Function
    listOf(1, 2, 3, 4).filter(x -> x % 2 == 0).map(x -> x * x).sum();

    ## Func params
    let f(i fn(x Int) Int) = i(1);
    f((x Int) Int -> x);
    f(x -> x);

    do_something_void();
    ## use _ discard return value
    _ = do_something_with_params(3, "test");

    ## if-do, single branch structure
    if a < b then {
        ...
    }

    ## with-init
    if let a = 1; a < 0 then {
        ...
    }

    ## if-then-else, double branch structure
    let v = if true then 0 else 0;
    if true then {
        ...
    } else {
        ...
    }

    if a then {
        ...
    } else if b then {
        ...
    } else {
        ...
    }

    let op [Int]Option = Some(1);
    if op is Some(v) then {
        printLine(v)
    }

    ## while-do, single branch structure
    while a < b then {
        ...
    }

    ## with-init
    while let mut i = 0; i < 10; i += 1 then {
        printLine(i)
    }

    ## while-then-else, double branch structure, break can with value
    let v = while true then break 1 else 2;
    while true then {
        ...
    } else {
        ...
    }

    let iter [Int]Iterator = listOf(1,2,3).iterator();
    while iter.next() is Some(v) then {
        printLine(v)
    }

    ## match
    x match {
        1 then "a",
        2 then "b",
        3 then "c",
        _ then "d",
    }

    ## same as let-in
    somePair match (a, b) then a + b;

    ## foreach-do
    array foreach item then {
        ...
    }

    ## Loop, use identify to take out single item
    array foreach item then printLine(item);
    
    ## take index and value, both worked at Dictionary
    array.enumerate() foreach (index, value) then {
        printLine((index, value))
    }
    
    0..10 foreach i then {
        printLine(i)
    }

    0..100 foreach i then if i % 2 == 0 then print(i);
    
    array foreach {
        1 then "a",
        2 then "b",
        3 then "c",
        _ then "d",
    }

    let nb = 42;
    nb match {
        >= 0 & <= 7 | 8 | 9 then 
            print("single digit"),
        10 then 
            print("double digits"),
        >= 11 & <= 99 then 
            print("double digits"),
        >= 100 & <= 999 then 
            print("triple digits"),
        _ then 
            print("four or more digits"),
    }

    if foo() is A(x) and bar(x) is B(y) then {
        do_stuff_with(x, y)
    } else {
        some_long_expression
    }

    let param_env(tcx TyCtxt, def_id DefId) ParamEnv = {
        if tcx.describe_def(def_id) is Some(Def.Existential(_))
            and tcx.hir.as_local_node_id(def_id) is Some(node_id)
            and tcx.hir.get(node_id) is hir.map.NodeItem(item)
            and item.node is hir.ItemExistential(exist_ty)
            and exist_ty.impl_trait_fn is Some(parent)
        then return param_env(tcx, parent);

        ...
    }

    ## data type define
    type Button(width Int, height Int, background String, title String) {
        this.click() Void = {
            printLine(title);
            doSomeThingA();
            doSomeThingB();
        }
    }

    ## private members
    type Image(
        private width Int, 
        private height Int, 
        private source String,
    );

    ## abstract type define
    type Animation {
        this.move(s Int) Void,
        this.stop() Void,
    }

    ## Combine Template
    type ImageButton(as image Image, as button Button);
    given ImageButton with {
        ## Implement Interface
        this.move(s Int) Void = {
            let t = 5000/s;
            play( s + t );
        }
        this.stop() Void = {}
    }

    ## Create an Template object
    let btn = Button(1, 2, "Cancel");
    let img = Image(1, 2, "?.jpg");
    let mut ib ImageButton = Image(img, btn);
    ib = (img, btn);
    ## Calling property
    ib.title = "OK";
    ## Calling method
    ib.show();
    ## Calling protocol
    ib.move(6);

    ## Use Interface
    let play_animation(a Animation) = {
        a.move(1000);
        a.stop();
    }
    play_animation(ib);

    ## Annotation
    #Table("user") #Property(false, name = "d", hide = true)
    type mut User(
        #Column("id") #Required #Key
        id String,
        #Column("nick_name") #Required
        nick_name String,
        #Column("time_update") #Required
        time_update Int,
    );
    
    ## Generic Type
    type mut [T Any]Table(data T);
    given[T Any] on [T]Table with {
        mut this.setData(d T) Void = {
            this.data = d;
        }
    }
    [Int]Table(1);

    ## Generic function
    let [T Addable]add(x1 T, x2 T) T = x1 + x2;
    [Int]add(1, 2);

    type Void();

    type Color = { Red(); Green(); Blue() }

    type Point(x Int, y Int);

    type [T1 Any, T2 Any]Pair(first T1, second T2);

    type [T Any]Option = { Some(value T); None() }

    let opt() = {
        let mut a [Int]Option = Some(1);
        a = None();
        a match {
            Some(v) then printLine(v),
            None then printLine("none"),
        }

        let mut b [[Int]Option]Option = [[Int]Option]Some([Int]Some(2));
        b = [[Int]Option]Option.Some([Int]Option.Some(2));

        b match {
            Some(Some(v)) then printLine(v),
            Some(None) then printLine("some(none)"),
            None then printLine("none"),
        }
    }

    type mut [T Any]MyList(arr [T]);
    ## operator override
    given[T Any] on [T]MyList with {
        ## a + e
        mut this.plus(element T) Void = {
            this.arr = this.arr.append(element);
        }
    }
    given[T Any] on [T]MyList with {
        ## e = a[i]
        this.get(index Int) T = this.arr[index];
        ## a[i] = e
        mut this.set(index Int, element T) Void = this.arr[index] = element;
    }
    
    ## Iterator pattern
    type mut [T Any]Iterator = {
        mut this.next() [T]Option;
    }

    type [T Any]Iterable = {
        this.iter() mut [T]Iterator;
    }

    type [T Any]ListNode = {
        Empty();
        Node(head T, tail [T]ListNode);
    } with {
        this.iter() mut [T]Iterator = mut ListNodeIterator(this);
    }

    type mut [T Any]ListIterator(li [T]ListNode);

    given[T Any] on [T]ListIterator with
        mut this.next() [T]Option =
            if this.li is Node(h, t) then {
                this.li = t;
                Some(h)
            } else {
                None()
            }

    type TreeNode = { Empty(); Node(val Int, left TreeNode, right TreeNode) }

    type Nat = { Zero(); Suc(n Nat) }
}

type Foo(value Int);

type Color = { Red(); Green(); Blue() }

type Color(rgb String) = {
    Red("ff0000");
    Green("00ff00");
    Blue("0000ff");
}

type Planet(mass Float, radius Float) = {
    Mercury(3.303e+23, 2.4397e6);
    Venus(4.869e+24, 6.0518e6);
    Earth(5.976e+24, 6.37814e6);
    Mars(6.421e+23, 3.3972e6);
    Jupiter(1.9e+27, 7.1492e7);
    Saturn(5.688e+26, 6.0268e7);
    Uranus(8.686e+25, 2.5559e7);
    Neptune(1.024e+26, 2.4746e7);
}

type [T Any]Option = { Some(value T); None() }

type [T Any]Expr = {
    IntExpr(value Int) is [Int]Expr;
    BoolExpr(value Bool) is [Bool]Expr;
    EqualExpr(left [T]Expr, right [T]Expr) is [Bool]Expr;
    AddExpr(left [Int]Expr, right [Int]Expr) is [Int]Expr;
}

type UserName(name String);
type Password(hash Hash);
type Identify = UserName | Password;
type [T Any]HashKey = [T]Equatable & Hashable;

given[T ToString] on [T]Option with {
    this.toString() String = 
        if this is Some(v)
        then "Some(\{v})" 
        else "None()";
}

given Foo with {
    this.toString() String = "foo";
}
given[T Any, R Any] fn(x T) R with {
    this.toAny() Any = this;
}

type [T Any]LinkedList = {
    Cons(head T, tail [T]LinkedList);
    Empty();
}

given[T Any] on [T]LinkedList with {
    new() This = Empty();
}

type mut [T Any]List = {
    this.get(index Int) T;

    mut this.set(index Int, element T) Void;
}

type mut [T Any]ArrayList = { ArrayList(_arr [T]Array, size Int) }
type mut [T Any]ArrayList(_arr [T]Array, size Int);

given[T Any] on [T]ArrayList is [T]List with {
    new() mut This = mut This([], 0);

    this.get(index Int) T = this._arr.get(index);

    mut this.set(index Int, element T) Void = this._arr.set(index, element);

    this.[R Any]map(f fn(x T) R) [R]Iterator = [T, R]MapIter(this, f);
}

given [Int]ArrayList with {
    this.sum() Int = reduce(this.iterator(), 0, (l, r) -> l + r);
}

type ToString = {
    this.toString() String;
}

given Int with {
    this.toString() String = cprintf(this);
}

given[T ToString] on [T]ArrayList with {
    this.toString() String = join_String(this.iterator());
}

given Int with {
    default() This = 0;
}

given String with {
    default() This = "";
}

given[T Any] on [T]Array with {
    default() This = [T]arrayOf();
}

type Any = {}

type [T]Iterator = {
    mut this.next() [T]Option
}

given[T Any] on [T]Iterator with {
    mut this.[R Any]reduce(mut r R, f fn(a R, b T) R) = {
        while this.next() is Some(v) then {
            r = f(r, v)
        }
        r
    }
}

type mut InputStream = {
    mut this.read(to [Byte]Array) Int;
}

type mut OutputStream = {
    mut this.write(from mut [Byte]Array) Int;
    mut this.flush() Void;
}

type mut [T Any]Array(_source [T]RawArray, _start Int, _len Int) with {
    create(size Int, item T) = mut [T]Array(RawArray.new(size, item), 0, size);

    this.size() = this._len;

    this.get(index Int) = this._source[index + _start];
    
    mut this.set(index Int, value T) = this._source[index + _start] = value;
    
    [m mut]this.slice(start Int, len Int) m [T]Array = 
        [T]Array(this._source, start, len);
}

type mut [T Any]ArrayIterator(_source [T]Array, index Int) is [T]Iterator with {
    of(source [T]Array) = ArrayIterator(source, -1);
    
    mut this.next() [T]Option = 
        if this.index < this._source.size() then {
            this.index += 1;
            Some(this._source[this.index])
        } else {
            None()
        }
}

type String(_data [Char]Array) with {
    of(data [Char]Array) String = String(data.clone());

    this.toString() String = String(this._data.clone());

    this.clone() String = String(this._data.clone());

    this.iter() mut StringIterator = StringIterator.of(this);
}

type mut StringIterator(_source String, index Int) is [Char]Iterator with {
    of(source String) = mut StringIterator(source, -1);
    
    mut this.next() [Char]Option = 
        if this.index < this._source._data.size() then {
            this.index += 1;
            Some(this._source[this.index])
        } else {
            None()
        }
}

type mut [T Any]Node(value T, next [[T]Node]Option);

type mut [T Any]LinkedList(head [[T]Node]Option, size Int) with {
    mut this.prepend(v T) Void = {
        let node = mut Node(v, None());
        if this.head is None then {
            this.head = node;
        } else {
            node.next = this.head;
            this.head = node;
        }
        this.size += 1;
    }
}

