// Grammar Overview

// Export Name Space
mod demo;

// Import Name Space
use {
    System;
    System:Text;
    System:Threading:Tasks;
    System:ComponentModel:DataAnnotations:Schema;
    System:ComponentModel:DataAnnotations;
    . = IO:File; // 可以隐藏元素使用内容
};

let main() Void = {
    // Define, 一般情况下编译器会自动判断类型
    let string String = "10";
    let number Float = 1.2;
    let integer Int = 123;
    let boolean Bool = true;
    let smallFloat = (1.2).to_Float32(); // basic obj convert

    // Const
    let PI = 3.141592653;

    // Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}";

    // Array
    let array Array[Int] = array_of(1, 2, 3);

    // List
    let list List[Int] = list_of(1, 2, 3, 4, 5);
    print( list[0] ); // 使用下标获取

    // Dictionary, 前面为key，后面为value
    let dict Dict[String, Bool] = dict_of(("1", false), ("2", true));
    print( dict["1"] ); // 使用key获取

    // Function
    let f(a Int) Int = a;

    // Function with no params no return
    let do_something_void() Void = {
        do_something_a();
        do_something_b();
    };

    // Full Function with params and return
    let do_something_with_params(x Int, y String) Pair[Int, String] = (x, y);

    // Function type
    let f (Int, Int)-> Int = (x Int, y Int) Int -> x + y;
    let f (Int, Int)-> Int = (x, y) -> x + y;
    let f(x Int, y Int) Int = x + y;
    let f(x Int, y Int) = x + y;
    let g() Void = {};
    let g ()-> Void = () -> {};

    // Currying
    let add = (x Int) -> (y Int) -> x + y;
    let add (Int) -> (Int) -> Int = (x) -> (y) -> x + y;
    let add(x Int) (y Int) Int = x + y;

    // Lambda Function
    list_of(1, 2, 3, 4).filter((x) -> x % 2 == 0).map((x) -> x * x).sum();

    // Func params
    let f(i (Int)-> Int) = i(1);
    f((x) Int -> x);
    f((x) -> x);

    do_something_void();
    // 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test");

    // Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    let v = if true then 0 else 0;
    if true then {
        0
    } else {
        0
    };

    if a then {
        0
    } else if b then {
        0
    } else {
        0
    };

    if let a = 1; a < 0 then {
        0
    } else if let c = 3; a == c then {
        0
    } else {
        0
    };

    let op Option[Int] = Some(1);
    if op is Some(v) then {
        v
    } else {
        0
    };

    if let op = Some(1); op is Some(v) then {
        v
    } else {
        0
    };

    when x 
    is 1 then "a"
    is 2 then "b"
    is 3 then "c"
    is _ then "d";

    // Judge obj
    if ib is Image_Button it then {
        it.show()
    };

    // Loop, use identify to take out single item
    for array is item loop {
        print(item)
    };
    // take index and value, both worked at Dictionary
    for array.withIndex() is (index, value) loop {
        print(index, value)
    };
    
    // Conditional
    let mut a = 0;
    while a < 10 then {
        a += 1;
    };

    while let mut i = 0; i < 10 then {
        i += 1;
    };

    // while expression, value from break or else
    while a < 10 then break 1 else 2;

    // 可以通过 this 来访问包自身属性或方法，当作为指针类型使用时 this 是指针，否则是值类型。 this 可以自定义。
    def Button(width Int, height Int, background String, title String) {
        click() Void = {
            print( title );
            doSomeThingA();
            doSomeThingB();
        };
    };
    // 私有属性，不能被外部访问
    def Image(mut _width Int, mut _height Int, mut _source String);

    // Interface
    def Animation {
        move(s Int) Void;
        stop() Void;
    };

    // Combine Template
    def Image_Button(as image Image, as button Button) Animation {
        // Implement Interface
        move(s Int) Void = {
            t = 5000/s;
            play( s + t );
        };
        stop() Void = {};
    };

    // Create an Template object
    let btn = Button(1, 2, "Cancel");
    let img = Image(1, 2, "?.jpg");
    let mut ib Image_Button = Image(img, btn);
    ib = (img, btn);
    // Calling property
    ib.title = "OK";
    // Calling method
    ib.show();
    // Calling protocol
    ib.move(6);

    // Use Interface
    let play_animation(a Animation) = {
        a.move(1000);
        a.stop();
    };
    play_animation(ib);

    // Annotation
    `table("user"), property(false, name = "d", hide = true)`
    def User(
        `column("id"), required, key`
        id String,
        `column("nick_name"), required)`
        nick_name String,
        `column("time_update"), required)`
        time_update Int
    );
    
    // Generic Template
    def Table[T Any](data T) {
        setData(d T) Void = {
            data = d;
        };
    };
    Table[Int](1);
    // Generic function
    let Add[T Addable](x1 T, x2 T) T = x1 + x2;
    Add[Int](1, 2);

    def Void();

    def Color is Red() | Green() | Blue();
    def Color {
        is Red | Green | Blue;
    };
    def Red() Color;
    def Green() Color;
    def Blue() Color;

    def Point(x Int, y Int);

    def Pair[T1 Any, T2 Any](first T1, second T2);

    def Option[T Any] is Some(value T) | None();
    def Option[T Any] {
        is Some | None;
    };
    def Some[T Any](value T) Option[T];
    def None[T Any]() Option[T];

    let opt() = {
        let a Option[Int] = Some(1);
        when a 
        is Some(v) then print(v)
        is None then print("none");
    };

    // operator override
    def MyList[T Any](arr Array[T]) Addable[T] & MutIndexable[T] {
        // a + e
        plus(element T) Void = {
            arr = arr.append(element);
        };
        // e = a[i]
        get(index Int) T = arr[index];
        // a[i] = e
        set(index Int, element T) Void = arr[index] = element;
    };

    // Iterator pattern
    def Iterator[T Any] {
        next() Option[T];
    };

    def Iterable[T Any] {
        iter() Iterator[T];
    };

    def ListNode[T Any] is None() | Node(head T, tail ListNode) {
        iter() Iterator[T] = ListNodeIterator(this);
    };

    def ListIterator[T Any](mut li ListNode[T]) {
        next() Option[T] = if li is Node(h, t) then {
            li = t;
            Some(h)
        } else None();
    };

    def TreeNode is None() | Node(val Int, left TreeNode, right TreeNode);

    def Nat is Zero() | Suc(n Nat);
};

/*
1. 数据是事物本身既有的
1. 事物的行为是由事物的数据决定的
1. 事物的行为可以根据所在环境的不同而有差异
1. 分类是对事物的抽象，通常形成于事物出现之后。
1. 分类描述某些特征，以此区分不同的事物。

1. 所有操作符都是函数
1. 所有操作符函数都用具体名称函数，擦作符作为语法糖
1. 操作符函数都是接收者函数，面向对象
1. 基础数字类型应该是平台相关类型，提供最大兼容性
1. 没有空指针
1. 没有继承
1. 没有函数重载
1. 没有字面量重载
1. 数字字面量只有一种类型，可以使用类型标注限定字面量类型
1. 没有集合字面量
1. 没有隐式转换
1. 有泛型
1. 没有型变
1. 没有泛型特化
1. 有模式匹配
1. 有变长参数
1. 没有值类型，统一是引用类型
1. 没有构造函数
1. 强制分号
*/
