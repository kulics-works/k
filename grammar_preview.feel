// Grammar Overview

// Export Name Space
mod demo;

// Import Name Space
use {
    System;
    System::Text;
    System::Threading::Tasks;
    System::ComponentModel::DataAnnotations::Schema;
    System::ComponentModel::DataAnnotations;
    . = IO::File; // 可以隐藏元素使用内容
};

let main() => {
    // Define, 一般情况下编译器会自动判断类型
    let string : String = "10";
    let number : Float = 1.2;
    let integer : Int = 123;
    let boolean : Bool = true;
    let smallFloat = (1.2).to_Float32(); // basic obj convert

    // Const
    let PI = 3.141592653;

    // Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}";

    // Array
    let array : [Int] = array_of(1, 2, 3);
    let array2 : [Int] = [1, 2, 3];

    // List
    let list : List[Int] = list_of(1, 2, 3, 4, 5);
    print( list[0] ); // 使用下标获取

    // Map, 前面为 key，后面为 value
    let map : Map[String, Bool] = map_of(("1", false), ("2", true));
    print( map["1"] ); // 使用key获取

    // Function
    let f(a : Int) : Int => a;

    // Function with no params no return
    let do_something_void() : () => {
        do_something_a();
        do_something_b();
    };

    // Full Function with params and return
    let do_something_with_params(x : Int, y : String) : (a : Int, b : String) => (x, y);

    // Function type
    let f : (x : Int, y : Int)->Int = (x : Int, y : Int) : Int => x + y;
    let f : (Int, Int)->Int = (x, y) => x + y;
    let f(x : Int, y : Int) : Int => x + y;
    let f(x : Int, y : Int) => x + y;
    let g() : () => {};
    let g : ()->() = () => {};

    // Currying
    let add = (x : Int) => (y : Int) => x + y;
    let add : (Int)->(Int)->Int = x => y => x + y;
    let add(x : Int) => (y : Int) => x + y;
    let add(x : Int)(y : Int) => x + y;
    let v = add(1)(2);

    // Lambda Function
    list_of(1, 2, 3, 4).filter((x) => x % 2 == 0).map((x) => x * x).sum();

    // Func params
    let f(i : (Int)->Int) => i(1);
    f((x) : Int => x);
    f((x) => x);

    do_something_void();
    // 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test");

    // Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    let v = if true then 0 else 0;
    if true then {
        0
    } else {
        0
    };

    if a then {
        0
    } else if b then {
        0
    } else {
        0
    };

    if let a = 1; a < 0 then {
        0
    } else if let c = 3; a == c then {
        0
    } else {
        0
    };

    let op : Option[Int] = Some 1;
    if op is Some(v) then {
        v
    } else {
        0
    };

    if let op = Some(1); op is Some(v) then {
        v
    } else {
        0
    };

    when x is {
        1 => "a"
        2 => "b"
        3 => "c"
        _ => "d"
    };

    // Judge obj
    if ib is ImageButton it then {
        it.show()
    };

    // Loop, use identify to take out single item
    for array is item loop {
        print(item)
    };
    // take index and value, both worked at Dictionary
    for array.withIndex() is (index, value) loop {
        print(index, value)
    };
    
    // Conditional
    let mut a = 0;
    while a < 10 then {
        a += 1;
    };

    while let mut i = 0; i < 10 then {
        i += 1;
    };

    // while expression, value from break or else
    while a < 10 then break 1 else 2;

    // 可以通过 this 来访问包自身属性或方法，当作为指针类型使用时 this 是指针，否则是值类型。 this 可以自定义。
    let Button(width : Int, height : Int, background : String, title : String) {
        click() : Void => {
            print( title );
            doSomeThingA();
            doSomeThingB();
        };
    };
    // 私有属性，不能被外部访问
    let Image(mut _width : Int, mut _height : Int, mut _source : String);

    // Interface
    let Animation {
        move(s : Int) : Void;
        stop() : Void;
    };

    // Combine Template
    let ImageButton(as image : Image, as button : Button) : Animation {
        // Implement Interface
        move(s : Int) : Void => {
            t = 5000/s;
            play( s + t );
        };
        stop() : Void => {};
    };

    // Create an Template object
    let btn = Button(1, 2, "Cancel");
    let img = Image(1, 2, "?.jpg");
    let mut ib : ImageButton = Image(img, btn);
    ib = (img, btn);
    // Calling property
    ib.title = "OK";
    // Calling method
    ib.show();
    // Calling protocol
    ib.move(6);

    // Use Interface
    let play_animation(a : Animation) => {
        a.move(1000);
        a.stop();
    };
    play_animation(ib);

    // Annotation
    `table("user"), property(false, name = "d", hide = true)`
    let User(
        `column("id"), required, key`
        id : String,
        `column("nick_name"), required)`
        nick_name : String,
        `column("time_update"), required)`
        time_update : Int
    );
    
    // Generic Template
    let Table[T : Any](data : T) {
        setData(d : T) : Void => {
            data = d;
        };
    };
    Table[Int](1);
    // Generic function
    let Add[T : Addable](x1 : T, x2 : T) : T => x1 + x2;
    Add[Int](1, 2);

    let Void = ();

    let Color {
        case Red;
        case Green;
        case Blue;
    };

    let Point(x : Int, y : Int);

    let Pair[T1 : Any, T2 : Any](first : T1, second : T2);

    let Option[T : Any] {
        case Some(value : T);
        case None;
    }

    let opt() => {
        let mut a : Option[Int] = Some(1);
        a = None();
        when a is {
            case Some(v) => print(v)
            case None => print("none")
        };

        let b : Option[Option[Int]] = Some(Some(2));
        when b is {
            case Some(Some(v)) => print(v)
            case Some(None) => print("some(none)")
            case None => print("none")
        };
    };

    let Foo(v : Int);
    let (a : Foo)getV() : Int => a.v;
    let (a : Foo)typeName() : String => "Foo";
    let Bar(v : Int);

    let I = where {
        getV() : Int;
        typeName() : String;
    };

    // operator override
    let MyList[T : Any](arr : [T]) : Addable[T] & MutIndexable[T] {
        // a + e
        plus(element : T) : Void => {
            arr = arr.append(element);
        };
        // e = a[i]
        get(index : Int) : T => arr[index];
        // a[i] = e
        set(element : T, index : Int) : Void => arr[index] = element;
    };

    // Iterator pattern
    let Iterator[T : Any] = {
        next() : Option[T];
    };

    let Iterable[T : Any] = {
        iter() : Iterator[T];
    };

    let ListNode[T : Any] =
        | None()
        | Node(head : T, tail : ListNode[T]);
    let (this : ListNode[T])iter() : Iterator[T] => ListNodeIterator(this);

    let ListIterator[T : Any](mut li : ListNode[T]);
    let (this : ListIterator[T])next() : Option[T] => 
        if li is Node(h, t) then {
            li = t;
            Some(h)
        } else None();

    let TreeNode =
        | None()
        | Node(val : Int, left : TreeNode, right : TreeNode);

    let Nat =
        | Zero
        | Suc(n : Nat);
};


let Foo(value : Int)

let Color =
    | Red()
    | Green()
    | Blue()

let Color(rgb : String) =
    | Red("ff0000")
    | Green("00ff00")
    | Blue("0000ff")

let Planet(mass : Float, radius : Float) =
    | Mercury(3.303e+23, 2.4397e6)
    | Venus(4.869e+24, 6.0518e6)
    | Earth(5.976e+24, 6.37814e6)
    | Mars(6.421e+23, 3.3972e6)
    | Jupiter(1.9e+27,   7.1492e7)
    | Saturn(5.688e+26, 6.0268e7)
    | Uranus(8.686e+25, 2.5559e7)
    | Neptune(1.024e+26, 2.4746e7)

let Option[T] = 
    | Some(value : T)
    | None()

let Expr[T] =
    | IntExpr(value : Int) : Expr[Int]
    | EqualExpr(left : Expr[Int], right : Expr[Int]) : Expr[Bool]
    | AddExpr(left : Expr[Int], right : Expr[Int]) : Expr[Int]

type UserName(name : String)
type Password(hash : Hash)
type Identify = UserName | Password
type HashKey[T] = Equatable[T] & Hashable

let (this : Option[T])toString() : String => 
        if this is Some(v) then "Some(\{v})" else "None()"

let (this : Foo)toString() : String => "foo"

let (this : Show)print() : () => stdout::write(this.toString())

let [T, R](this : (T)->R)toAny() : Any => this

type List[T](_arr: Array[T])

let [T]List[T].new(): List[T] => List[T]([])

let [T](a: List[T])get(index: Int): T => a._arr.get(index)

let [T](a: mut List[T])set(index: Int, element: T): () => a._arr.set(index, element)

let [T](a: List[T])map[R: Any](f: (T)->R): Iterator[R] => MapIter[T, R](a, f)

let [T: To_String](a: List[T])to_String(): String => join_String(a.Iterator())

let (a: List[Int])sum(): Int => reduce(a.Iterator(), 0, (l, r) => l + r)

type List[T: Any](_arr: Array[T]) = {
    new(): List[T] => List[T]([])

    this.get(index: Int): T => this._arr.get(index)

    mut this.set(index: Int, element: T): () => this._arr.set(index, element)
}

type List[T: Any] = {
    this.map[R: Any](f: (T)->R): Iterator[R] => MapIter[T, R](this, f)
}

type List[T: To_String]: To_String = {
    this.to_String(): String => join_String(this.Iterator())
}

type To_String = {
    this.to_String(): String
}

type Readable = {
    mut read(buf: mut Array[Byte]): Int
    size(): Int
}

type Writable = {
    mut write(buf: mut Array[Byte]): Int
    mut flush(): ()
}

/*
1. 数据是事物本身既有的
1. 事物的行为是由事物的数据决定的
1. 事物的行为可以根据所在环境的不同而有差异
1. 分类是对事物的抽象，通常形成于事物出现之后。
1. 分类描述某些特征，以此区分不同的事物。

1. 使用实例成员函数重载操作符
1. 默认数字类型是平台相关类型
1. 没有空指针
1. 没有继承
1. 没有函数重载
1. 没有字面量重载
1. 没有集合字面量
1. 没有隐式转换
1. 泛型
1. 模式匹配
1. 变长参数
1. 没有构造函数
1. 类型上区分可变和不可变
1. 值类型只有不可变类型
*/
