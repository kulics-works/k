// Grammar Overview

// Export Name Space
mod demo

// Import Name Space
use {
    System
    System.Text
    System.Threading.Tasks
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    . = IO.File // 可以隐藏元素使用内容
}

func Main() {
    // Define, 一般情况下编译器会自动判断类型
    var string Str = "10"
    var number Num = 1.2
    var integer Int = 123
    var boolean Bool = true
    var smallFloat = (1.2).To_F32() // basic obj convert

    // Const
    var PI = 3.141592653

    // Mark String
    var format = "the value is \{integer}, \{number}, \{boolean}"

    // Array
    var array Array[Int] = Array_of(1, 2, 3)

    // List
    var list List[Int] = List_of(1, 2, 3, 4, 5)
    Print( list(0) ) // 使用下标获取

    // Dictionary, 前面为key，后面为value
    var dict Dict[Str, Bool] = Dict_of(new("1", false), new("2", true))
    Print( dict("1") ) // 使用key获取

    // Anonymous Template
    var v1 = type(title Str, number Int)("nnn", 8)
    var v2 = type(title, number)("nnn", 8) // obj infer

    // Function
    func f(a Int) Int {
        ret a
    }

    // Function with no params no return
    func do_something_void() {
        do_something_a()
        do_something_b()
    }

    // Full Function with in params and out params
    func do_something_with_params(x Int, y Str) (x Int, y Str) {
        ret new(x, y)
    }

    // Function can omit return obj
    var f func(Int,Int) Int = func x Int, y Int { x + y }
    func f(x Int, y Int) { x + y }

    // Currying
    var add = func x { func y { x + y } } 

    do_something_void()
    // 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test")

    // Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    var v = if a { b } else { c }
    if a {
        b
    } else {
        c
    }

    if a {
        b
    } else if c {
        d
    } else {
        e
    }

    if var (a, b) = (1, 2); a < b {
        d
    } else if var c = 3; a == c {
        d
    }

    if (1, 2) case (a, b) where a < b {
        d
    } else if 3 case c where a == c {
        d
    }

    // Judge obj
    if ib case it Image_Button {
        it.show()
    }

    // Complex Judge
    if x case in 0 to 6 or 7 or 8 or 9 {
        do_something_a()
    } case 14 {
        do_something_b()
    } case < 18 {
        do_something_c()
    } case > 18 and < 32 {
        do_something_d()
    } case it Int {
        do_something_e()
    } else {
        do_something()
    }

    // always do
    if {
        do_some_thing()
    }

    // Loop, use identify to take out single item
    for array case item {
        Print(item)
    }
    // take index and value, both worked at Dictionary
    for array.WithIndex() case index, value {
        Print(index, value)
    }

    // Range
    for 0 to 100 case it {
        Print(it)
    }
    for 0 until 100 case it {
        Print(it)
    }
    for 10 downto 1 by 2 case it {
        Print(it)
    }
    
    // Conditional
    var a = 0
    for a < 10 {
        a += 1
    }
    for var i = 0; i < 10 {
        i += 1
    }
    // Infinite
    for {
        if a > b {
            break // jump out loop
        }
        continue // continue
    }
    
    // Check, listen the Exception Function
    var fi = open_file("./test.feel")
    try var f = read_file("demo.feel"); f {
        do_some_thing()
    }
    try {
        do_some_thing()
    } case ex Exception {
        throw ex // Use ! <- to throw an Exception
    } else {
        fi.dispose()
    }

    // Template
    type View(width Int, height Int, background Str)

    // 可以通过 this 来访问包自身属性或方法，当作为指针类型使用时 this 是指针，否则是值类型。 this 可以自定义。
    type Button(width Int, height Int, background Str, title Str) {
        func Click() {
            Print( this.title )
            doSomeThingA()
            doSomeThingB()
        }
    }
    // 私有属性，不能被外部访问
    type Image(_width Int, _height Int, _source Str) {
        func Init(w Int, h Int, s Str) Image {
            this._width, this._height, this._source = w, h, s
            ret this
        }
    }

    // Interface
    type Animation {
        func Move(s Int)
        func Stop()
    }

    // Combine Template
    type Image_Button(as Image, as Button, title Str) {
        // Implement Interface
        func Move(s Int) {
            t = 5000/s
            play( s + t )
        }
        func Stop() {}

        func Init(w Int, h Int) Image_Button {
            this.Image.Init(w, h, "img")
            this.title = "img btn"
            ret this
        }
    }

    // Create an Template object
    var ib = Image_Button(1, 2)
    ib = new(2, 1)
    // Calling property
    ib.title = "OK"
    // Calling method
    ib.Show()
    // Calling protocol
    ib.Move(6)

    // Use Interface
    func play_animation(a Animation) {
        a.Move(1000)
        a.Stop()
    }
    play_animation(ib)

    // Create an object with simple assign
    var ib2 = Image_Button(
        title = "Cancel",
        background = "red"
    )

    // Create an object with params
    var img = Image(30, 20, "./icon.png")
    var imgbtn = Image_Button().Init(1, 1)

    func task(i Int) (r Int) {
        // make a function to async
        go do_some_thing_A()
        // make channel
        var ch = Chan[Int](1)
        // await
        ch <~ i
        // await
        ret <~ ch
    }

    var x = task(6)

    // Annotation
    `table("user"), property(false, name = "d", hide = true)`
    type User(
        `column("id"), required, key`
        id Str,
        `column("nick_name"), required)`
        nick_name Str,
        `column("time_update"), required)`
        time_update Int
    )

    // Optional obj
    var a Opt[Int] = nil
    // Safe Call
    var e = a?.To_Str()
    // OrElseValue
    var f = a ?: 128

    // Reference
    func swap(x ref Int, y ref Int) {
        x, y = y, x
    }
    var a, b = 1, 2
    swap(ref a, ref b)
    
    // Generic Template
    type Table[T Any](data T) {
        func Set_data(d T) {
            data = d
        }
    }
    Table[Int](1)
    // Generic function
    func Add[T Any](x1 T, x2 T) (r T) {
        ret x1 + x2
    }
    Add[Int](1, 2)

    // Lambda Function
    arr.select(func it { it > 2 })

    // Func params
    func f(i func(Int)Int) {
        i(1)
    }
    f(func x Int {
        ret y
    })

    type Color case Red, Green, Blue
    type Unit()
    type Person(age Int, name Str)
    type Man(as p Person)
    type Option[T] {
        case None
        case T
    }
    type Result[T] {
        case Error
        case T
    }
    type Error {
        func error() Str
    }
    func Function(age Int, name Str) {}
    type Option[T] {
        case None
        case T
    }
    impl Option[T] {
        func orElse(v T) T {
            if this case i T {
                ret i
            } else {
                ret v
            }
        }
    }

    var op ?Int = nil
    op = 1
    if op case v Int {
        Print(v)
    }
    if var v = op as Int {
        Print(v)
    }
    
    // operator override
    type Complex(v Int, i Int)
    impl Complex {
        // Complex + Complex
        func Plus(x Complex) (r Complex) {
            ret Complex(v + x.v, i + x.i)
        }
        // y = Complex(x)
        func Get(x Bool) (r Int) {
            ret if x { v } else { i }
        }
        // Complex(x) = y
        func Set(x Bool, y Int) {
            if x {
                v = y
            } else {
                i = y
            }
        }
    }
}

class Nullable[T] case Nil, T {
    getOrElse(value T) T {
        if this case v T {
            ret v
        } else {
            ret value
        }
    }
}
object Nil {}

class Option[T] case Nil, Some[T] {
    getOrElse(value T) T {
        if this case v Some {
            ret v.value
        } else {
            ret value
        }
    }
}

record Some[T] {
    value T
}

class Iterator[Item] {
    next() Option[Item]
}

class Iterable[Item] {
    iter() Iterator[Item]
}

class Collection[Item] as Iterable[Item] {
    size() Int
    isEmpty() Bool {
        ret size() == 0
    }
}

class List[Item] as Collection[Item] {
    append(item Item) Void
    get(index Int) Item
    set(index Int, item Item) Void
}

func arrayListOf[Item](items Collection[Item]) ArrayList[Item] {
    let data = newArrayListWithCap[Item](items.size())
    for items case v {
        data.append(v)
    }
    ret data
}

func newArrayList[Item]() ArrayList[Item] {
    ret ArrayList[Item](Array[Option[Item]](10, nil), 0)
}

func newArrayListWithCap[Item](cap Int) ArrayList[Item] {
    ret ArrayList[Item](Array[Option[Item]](cap, nil), 0)
}

record ArrayList[Item] {
    array Array[Option[Item]]
    len Int
}

impl ArrayList[Item] {
    iter() Iterator[Item] {
        ret ArrayListIterator(this, 0)
    }

    size() Int {
        ret this.len
    }

    isEmpty() Bool {
        ret this.len == 0
    }

    append(item Item) Void {
        if this.len < this.array.size() {
            this.array.(this.len) = item
        } else {
            let newArray = Array[Option[Item]](this.array.size() * 1.5, nil)
            for this.array.WithIndex() case (i, v) {
                newArray.(i) = v
            }
            this.array = newArray
        }
        this.len += 1
    }

    get(index Int) Item {
        if index > 0 | index < this.len {
            if this.array.(index) case v Some[Item] {
                ret v.value
            }
        }
        throw OutOfRange()
    }

    set(index Int, item Item) Void {
        if index > 0 | index < this.len {
            this.array.(index) = Some(item)
        }
    }
}

class Equatable[T] {
    equals(other T) Bool
}

impl ArrayList[Item Equatable[Item]] {
    equals(other ArrayList[Item]) Bool {
        if this.len <> other.len {
            ret false
        }
        for this.array.WithIndex() case (i, v) {
            if not v.equals(other.array.(i)) {
                ret false
            }
        }
        ret true
    }
}

class Clone[T] {
    clone() T
}

impl ArrayList[Item] {
    clone() ArrayList[Item] {
        ret ArrayList(this)
    }
}

record ArrayListIterator[Item] {
    data ArrayList[Option[Item]]
    index Int
}

impl ArrayListIterator[Item Any] {
    next() Option[Item] {
        if this.index < this.data.size() {
            this.index += 1
            ret this.data.(this.index) 
        }
        ret nil
    }
}


1. 数据是事物本身既有的
1. 事物的行为是由事物的数据决定的
1. 事物的行为可以根据所在环境的不同而有差异
1. 分类是对事物的抽象，通常形成于事物出现之后。
1. 分类描述某些特征，以此区分不同的事物。

1. 所有操作符都是函数
1. 所有操作符函数都用具体名称函数，擦作符作为语法糖
1. 操作符函数都是接收者函数，面向对象
1. 基础数字类型应该是平台相关类型，提供最大兼容性
1. 没有空指针
1. 没有继承
1. 没有函数重载
1. 没有字面量重载
1. 数字字面量只有一种类型，可以使用类型标注限定字面量类型
1. 没有集合字面量
1. 没有隐式转换
1. 有泛型
1. 没有型变
1. 没有泛型特化
1. 有模式匹配
1. 有变长参数
1. 没有值类型，统一是引用类型
1. 没有构造函数
1. 

type Foo (value Int)

type I[T Any] class {
    plus(rhs T) T
    plusAssign(rhs T) Void
}

impl Foo is I[Int] {
    plus(rhs Int) Foo -> {
        ret Foo(this.value + rhs)
    }
    plusAssign(rhs Int) Void -> {
        this.value = this.value + rhs
    }
}

func f[T I[Int]](v Int) T -> {
    var a T = T.new()
    var b T = a.plus(v)
    b += v
    ret b
}

func f_Foo(v Int) Foo -> {
    var a Foo = Foo.new()
    var b Foo = a.plus(v)
    b += v
    ret b
}

func Main() {
    var x Int = 0
    var x = 0
    x = 0
    f[Foo](1)

    if(a) {
        b
    } else {
        c
    }
    for(a) {
        b
    } else {
        c 
    }

    if(var a = f(); a > 1) {
        b
    }
    if(a = f(); a > 1) {
        b
    }
    for(var a = f(); a > 1) {
        b
    }
    for(a = f(); a > 1) {
        b
    }

    if(a is i) {
        b
    }
    for(a is i) {
        b
    }

    if(var a = f(); a is i) {
        b
    }
    for(var a = f(); a is i) {
        b
    }

    if(x is a) {
        b
    } else is c {
        d
    }
    for(x is a) {
        b
    } else is c {
        d
    }

    var f1 Func[Void, Void] = fun() {}
    f1()
    var f2 Func[Int, Int] = fun(a) { a }
    f2 = fun(a) {
        a += 1
        ret a
    }
    f2(2)
    var f3 Func[(Int, Int), Int] = fun(a, b) { a + b }
    f3(1, 2)
    var f4 Func[Int, Func[Int, Int]] = fun(a Int) Func[Int, Int] { fun(b) { a + b } }
    f4 = fun(a) { fun(b) { a + b } }
    var f5 [T]Func[T, T] = fun[T](a T) { a }
}
