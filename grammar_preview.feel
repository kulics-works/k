// Grammar Overview

// Export Name Space
mod demo;

// Import Name Space
use {
    System
    System:Text
    System:Threading:Tasks
    System:ComponentModel:DataAnnotations:Schema
    System:ComponentModel:DataAnnotations
    . = IO:File // 可以隐藏元素使用内容
};

let main() Void = {
    // Define, 一般情况下编译器会自动判断类型
    let string Str = "10";
    let number Num = 1.2;
    let integer Int = 123;
    let boolean Bool = true;
    let smallFloat = (1.2).to_F32(); // basic obj convert

    // Const
    let PI = 3.141592653;

    // Mark String
    let format = "the value is \{integer}, \{number}, \{boolean}";

    // Array
    let array Array[Int] = array_of(1, 2, 3);

    // List
    let list List[Int] = list_of(1, 2, 3, 4, 5);
    Print( list(0) ); // 使用下标获取

    // Dictionary, 前面为key，后面为value
    let dict Dict[Str, Bool] = dict_of(new("1", false), new("2", true));
    Print( dict("1") ); // 使用key获取

    // Anonymous Template
    let v1 = case(title Str, number Int)("nnn", 8);
    let v2 = case(title, number)("nnn", 8); // obj infer

    // Function
    let f(a Int) Int = a;

    // Function with no params no return
    let do_something_void() = {
        do_something_a();
        do_something_b();
    };

    // Full Function with in params and out params
    let do_something_with_params(x Int, y Str) case(x Int, y Str) = {
        new(x, y)
    };

    // Function can omit return obj
    let f fn(Int,Int) Int = fn(x Int, y Int) { x + y };

    // Currying
    let add = fn(x) { fn(y) { x + y } } ;

    do_something_void();
    // 使用 _ 舍弃返回值
    _ = do_something_with_params(3, "test");

    // Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行
    let v = if (true) 0 else 0;
    if (true) {
        0
    } else {
        0
    };

    if (a) {
        0
    } else if (b) {
        0
    } else {
        0
    };

    if (let a = 1; a < 0) {
        0
    } else if (let c = 3; a == c) {
        0
    } else {
        0
    };

    let op Option[Int] = Some(1);
    if (op is Some(v)) {
        v
    } else {
        0
    };

    if (let op = Some(1); op is Some(v)) {
        v
    } else {
        0
    };

    when (x) {
        is 1 -> "a"
        is 2 -> "b"
        is 3 -> "c"
        is _ -> "d"
    };

    // Judge obj
    if (ib is Image_Button it) {
        it.show()
    };

    // Loop, use identify to take out single item
    for (array is item) {
        Print(item)
    };
    // take index and value, both worked at Dictionary
    for (array.withIndex() is (index, value)) {
        Print(index, value)
    };
    
    // Conditional
    let mut a = 0;
    while (a < 10) {
        a += 1;
    };
    while (let mut i = 0; i < 10) {
        i += 1;
    };

    // Template
    def View = case(width Int, height Int, background Str);

    // 可以通过 this 来访问包自身属性或方法，当作为指针类型使用时 this 是指针，否则是值类型。 this 可以自定义。
    def Button = case(width Int, height Int, background Str, title Str) {
        Click() Void = {
            Print( title );
            doSomeThingA();
            doSomeThingB();
        };
    }
    // 私有属性，不能被外部访问
    def Image = case(_width Int, _height Int, _source Str) {
        Init(w Int, h Int, s Str) Image = {
            this._width, this._height, this._source = w, h, s;
            this
        };
    }

    // Interface
    def Animation = any {
        Move(s Int) Void;
        Stop() Void;
    };

    // Combine Template
    def Image_Button = case(as Image, as Button, title Str) {
        // Implement Interface
        Move(s Int) Void = {
            t = 5000/s;
            play( s + t );
        };
        Stop() Void = {};

        Init(w Int, h Int) Image_Button = {
            this.Image.Init(w, h, "img");
            this.title = "img btn";
            this
        };
    }

    // Create an Template object
    let mut ib = Image_Button(1, 2);
    ib = (2, 1);
    // Calling property
    ib.title = "OK";
    // Calling method
    ib.Show();
    // Calling protocol
    ib.Move(6);

    // Use Interface
    let play_animation(a Animation) = {
        a.Move(1000);
        a.Stop();
    };
    play_animation(ib);

    // Create an object with simple assign
    let ib2 = Image_Button(
        title = "Cancel",
        background = "red"
    );

    // Create an object with params
    let img = Image(30, 20, "./icon.png");
    let imgbtn = Image_Button().Init(1, 1);

    let x = task(6)

    // Annotation
    `table("user"), property(false, name = "d", hide = true)`
    def User = case(
        `column("id"), required, key`
        id Str,
        `column("nick_name"), required)`
        nick_name Str,
        `column("time_update"), required)`
        time_update Int
    );

    // Optional obj
    let a Opt[Int] = nil;
    // Safe Call
    let e = a?.To_Str();
    // OrElseValue
    let f = a ?: 128;
    
    // Generic Template
    def Table[T Any] = case(data T) {
        Set_data(d T) Void = {
            data = d;
        };
    }
    Table[Int](1);
    // Generic function
    let Add[T Addable](x1 T, x2 T) T = x1 + x2;
    Add[Int](1, 2);

    // Lambda Function
    arr.select(fn(it) { it > 2 });

    // Func params
    let f(i fn(Int) Int) = i(1);
    f(fn(x) Int { y })

    def Color is Red() | Green() | Blue();
    def Unit();
    def Person(age Int, name Str);
    def Option[T] is None() | Some(v T);
    def Result[T] is Err(msg Error) | Ok(v T);
    def Error {
        error() Str;
    };
    let mut op Option[Int] = None;
    op = Some(1);
    if (op is Int v) {
        Print(v);
    };
};

// operator override
def MyList[T Any](arr Array[T]) {
    // a + e
    plus(element T) Void = {
        arr = arr.append(element);
    };
    // e = a.(i)
    get(index Int) T = arr.get(index);
    // a.(i) = e
    set(index Int, element T) Void = {
        arr.set(index, element)
    };
};

// Iterator pattern
def Iterator[T Any] {
    next() Option[T];
};

def Iterable[T Any] {
    iter() Iterator[T];
};

def List[T Any] is Nil | Cons(head T, tail List[T]) {
    iter() Iterator[T] = ListIterator(this)
};

def ListIterator[T Any](mut li List[T]) {
    next() Option[T] = if (li is Cons(h, t)) {
        li = t;
        h
    } else {
        None
    };
};

/*
1. 数据是事物本身既有的
1. 事物的行为是由事物的数据决定的
1. 事物的行为可以根据所在环境的不同而有差异
1. 分类是对事物的抽象，通常形成于事物出现之后。
1. 分类描述某些特征，以此区分不同的事物。

1. 所有操作符都是函数
1. 所有操作符函数都用具体名称函数，擦作符作为语法糖
1. 操作符函数都是接收者函数，面向对象
1. 基础数字类型应该是平台相关类型，提供最大兼容性
1. 没有空指针
1. 没有继承
1. 没有函数重载
1. 没有字面量重载
1. 数字字面量只有一种类型，可以使用类型标注限定字面量类型
1. 没有集合字面量
1. 没有隐式转换
1. 有泛型
1. 没有型变
1. 没有泛型特化
1. 有模式匹配
1. 有变长参数
1. 没有值类型，统一是引用类型
1. 没有构造函数
1. 强制分号
*/

def Eq[T Any] {
    equals(rhs T) Bool;
}

impl Int for Eq[Int] {
    equals(rhs Int) Bool = this == rhs;
}

let f[T Eq[T]](a T, b T) Bool = a.equals(b);
let a = f[Int](1, 1);
let g(a Eq[Int]) = a;
let b = g(1);

/*
class Eq<T>(val equals: (T, T) -> Boolean)
abstract class EqObject<T>() {
    abstract fun equals(v: T): Boolean
}

val IntEq = Eq<Int> { a, b -> a == b }
class IntEqObject(val obj: Int):EqObject<Int>() {
    override fun equals(v: Int): Boolean {
        return obj == v
    }
}

fun <T> f(ins: Eq<T>, a: T, b: T): Boolean {
    return ins.equals(a, b)
}

val a = f<Int>(IntEq, 1, 2)

fun g(a: EqObject<Int>) {
    a.equals(1)
}

val b = g(IntEqObject(1))
*/