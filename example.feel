mod example

use {
    System
    System.IO
    System.Collections.Generic
    System.ComponentModel.DataAnnotations.Schema
    System.ComponentModel.DataAnnotations
    System.Threading.Tasks

    example.example_static => .
}

/*
   // main function
*/
fun Main() {
    Print("main function")
    // run test
    Test_type()
    Test_operator()
    Test_string()
    Test_optional()
    Test_list()
    Test_dict()
    Test_switch()
    Test_if()
    Test_foreach()
    Test_while()
    var X = Test_func("testcall")
    Test_func_params(a = 1, b = 2,
    fun a, b, c, d {
        ret "", a, b, c
    })
    Test_check()
    Test_type_convert()
    Test_lambda()

    var Y = Test_tuple(1).To_Str()
    var P = example.App new ()

    P.C(1)
    Test_interface(P)

    P.Test_func_template[Int, Str](1, "2").Test_package()
    
    for true {
        break
    }
    
    if 1 == 1 {
        Print("test exception expression")
    }
    
    Read()
}

`get, set`
var static_x = 0

`get, set`
var static_y = "hello"

var static_g Int = 3

fun Test_tuple(i Int) (v Str) {
    ret "tuple"
}

fun Test_type() {
    var I1 I8 = 1              // sbyte
    var I2 I16 = 1             // short
    var I3 I32 = 1             // Int
    var I4 I64 = 1             // long
    var U1 U8 = 1              // byte
    var U2 U16 = 1             // ushort
    var U3 U32 = 1             // uint
    var U4 U64 = 1             // ulong
    var F1 F32 = 1             // float
    var F2 F64 = 1             // double
    var Char1 Chr = 'a'        // char
    var String1 Str = "123"    // string
    var Bool1 Bool = false     // bool
    var Int1 Int = 1           // Int
    var Num1 Num = 1.0         // double
    var Byte1 Byte = 1         // byte
    var Any1 Any = 1           // object
}

fun Test_operator() {
    var i Str = "128.687"
    i += ".890"
    var A = 003.141592653e3
    var b Int
    b = 2020_01_16
    b = 0b1010_1101
    b = 0X56_fa_C4
    b += Const_data
    b = + - b
    b = b + 1
    b = b * 2
    b = b / 2
    b = b % 2
    b = (b ^ 2).To_Int()
    Print(" mark string Int \b \{b}123{} \\{b} \{i, i}")
    Print(""" "raw" mark string \b
     Int \{b}123{} \ {}
      \{i}
    """)
    Print(""" 
       " raw "
        string
      """, """""")
    var c = false
    c = 1 <> 2
    c = 3 == 3
    c = 3 >= 1
    c = 1 <= 3
    c = not c
    c = true and false
    c = true or false
    var d = (2018.0309).To_Int()
    d = ~~ d && 1 || 2 ^^ 3 << 1 >> 2
    Print(b.To_Str(), d)
}

fun Test_string() {
    for "love programming" case E {
        if E == 'e' {
            Print("love programming")
        }
    }
}

fun Test_optional() {
    var a ?Int
    a = 1
    a?.To_Str()
    var B ?Str = ""
    B?.To_Str()
    var C ?Any = nil
    var D ?App = nil
    var E ?List[?Int] = List_of[?Int](0)
    E?.(0)?.To_Str()?.To_Str()
    var F = D ?: App new ()
}

fun Test_reference() {
    var x Int = 1
    var y ?Int = 2
    fun Swap(a !Int, b !?Int) {
        b, a = a, b ?: 2
    }
    Swap(x!, y!)
}

fun Test_list() {
    var Single = List_of(1)
    var numbers = List_of(1, 2, 5, 6, 8, 4)
    numbers.Append(3 + 7)
    numbers.Remove(6)
    var Three = 3
    numbers.(Three) = 5
    var take = numbers.(0)
    take = (In_package_array new ()).Arr.(2)
    var Anys = List_of[Any]("123", 432, App new ())
    var Numbers_in_numbers = List_of(List_of(1, 1, 1), List_of(1, 1, 1))
    Numbers_in_numbers.(0).(0) = 3
    var Empty = List[List[Int]] new ()
    var Array Array[Int] = Array_of(1, 2, 3)
    for numbers.WithIndex() case i, v {
        Print(i, " :", v)
    }
    var Slice = numbers.Slice(0, nil)
    var Slice2 = numbers.Slice(nil, 3)
}

fun Test_dict() {
    var Empty = Dict[Str, Dict[Int, Int]] new ()
    var temp = Dict_of(Pair_of("k1", 1), Pair_of("k2", 2))
    temp.("k3") = 3
    for temp.WithIndex() case k, v {
        Print(k)
        Print(v)
    }
    temp.Remove("k1")
    Print(temp.("k2"))
}

fun Test_combined_type() {
    // swift [Int:[[Str:[Str:[Str]]]]]
    // go map[Int][]map[Str]map[Str][]Str
    // c# Dictionary<Int,List<Dictionary<Str,Dictionary<Str,List<Str>>>>>
    var Feel Dict[Int, List[Dict[Str, Dict[Str, List[Str]]]]]
}

fun Test_if() {
    var X = 5
    if X == 2 { 
        Print(2)
    } else if X == 3 {
        Print(3)
    } else { 
        Print("else")
    }
    if X == 5 {
        Print("yes")
    }
}

fun Test_type_convert() {
    var A Any = Dict[Str, Int] new ()
    var B = A as Dict[Str, Int]
    var X = App new ()
    var Y = X as Program
    var Z1 = (12.34).To_F32()
    var Z2 = Z1.To_I64()
    Print( Z2.To[Any]().To[I64]() )
    Print( Y is Program )
    Print( (X as Program).running )
    Print( typeof(Program) )
}

fun Test_switch() {
    var X Any = 3
    if X case == 1, 2, 3 {
        Print("1,2,3")
    } case == nil {
        Print("null")  
    } case s Str {
        Print("string")
    } case i Int {
        Print("Int")
    } else {
        Print("default")
    }
}

fun ten() (v Int) {
    ret 10
}

fun Test_foreach() {
    Print("\n 0 up to 10 step 2: ")
    for 0.to(ten()).by(2) case E {
        Print(E, ", ", "")
    }
    Print("\n 0 up until 8: ")
    for 0.until(8) case E {
        Print(E, ", ", "")
    }
    Print("\n 8 down until 0: ")
    for 8.downuntil(0) case E {
        Print(E, ", ", "")
    }
    Print("\n 10 down to 0 step 2: ")
    for 10.downto(0).by(2) case E {
        Print(E, ", ", "")
        if E == 6 {
            continue
        }
    }
    Print("\n 0 to 7 reversed: ")
    for 0.until(8).Reversed() case E {
        Print(E, ", ", "")
    }
    for 0.until(8).Reversed().Reversed() case E {
        Print(E, ", ", "")
    }
    Print(" ")
    var Arr = List[Int] new ()
    for Arr case E {
        Print(E)
    }
    for 7.until(7) case E {
        Print(E)
        break
    }
}

fun Test_while() {
    var a = 0
    var B = 8
    for a < B {
        a += 1
    } else {
        Print("loop no break")
    }
}

fun Test_check() {
    var z1 ?Defer = nil
    try var Z2 = Defer new (); Z2 {
        try {
            z1 = Defer new ()
            try var Z3 = Defer new (); Z3 {
                var X = 1 * 1
                var Y = 1 + 1
            }
        } case ex IOException {
            throw ex
        } case e {
            throw e
        } else {
            if z1 <> nil {
                z1.Dispose()
            }
        }
    }
}

fun Test_func(s Str = "func") (out1 Str, out2 Int) {
    s = s + "test"
    var I1 = 1+1*3*9/8
    var I2 = I1 + 5 + (I1 + 8)
    fun Infunc() {
        ret
    }
    Infunc()
    ret s, I2
}

fun Test_func_params(a Int, b Int, fn fun(Int, Int, Int, Int)(Str, Int, Int, Int),
    arr ...Int) (a Int, b Str, c Str) {
    ret 0, "", ""
}

fun Test_lambda() {
    fun Test1(fn fun(Int, Int)(Int, Int)) {
        var i1, i2 = fn(1, 2)
    }
    Test1(fun i1, i2 { ret i1, i2 })

    fun Test2(fn fun()(Int)) {
        var i1 = fn()
    }
    Test2(fun {1})

    fun Test3(fn fun(Int)) {
        fn(1)
    }
    Test3( fun it Int {
        Print(it)
    })
    Test3( fun it {
        Print(it)
    })
    fun Test4(fn fun(Int)(Int)) { 
        fn(18) 
    }
    Test4(fun it {it+1})
}

fun Test_define() {
    var a = 1
    if a == 1 {
        var b = 2
        b = 3
        a = 3
    } else if a == 2 {
        var b = 2
        b = 3
        if b == 2 {
            a = 1
        }
    } else {
        var b = 2
        b = 3
        a = 3
    }
    if a case == 1 {
        var b = 2
        b = 3
        a = 3
        if a == 3 {
            b = 1
            a = 1
        } else {
            a = 2
        }
    } case c Int {
        c = 2
        a = 1
    } else {
        var b = 2
        b = 3
        a = 3
    }
    try {
        a = 2
    } case e {
        e = Exception new ()
    }
}

fun Test_interface(i Protocol) {}

var Const_data = 256
var Const_data2 Str = "512"
var Const_data3 Int = Const_data
fun Const_function() (v Int) { 
    ret Const_data
}

fun 测试中文(甲 Int) (乙 Int) {
    var 乙 = 甲 + 1
    ret 乙
}

typ In_package_array(Arr List[Int])
typ In_package_array(->$me) {
    me.Arr = List_of(1,2,3,4,5)
}

typ Defer(data Str = "") {
    IDisposable
    fun Dispose() {}
}

typ App(
    i Int = 1,
    arr ?Array[Int] = nil,
    _Name Str = "name",
    _b Int = 3,
    `get, set`
    a Int = 5,
    `get, set`
    f Str = ""
) {
    Program
    Protocol

    fun Test_package() {
        var Item = Program new ()
        Item = new ()
        var Item2 = List[Int] new ()
        var Item3 = Dict[Str, Int] new ()
        var Item4 = Package_child new (1,2)
    }

    fun Test_func_template[t1, t2](data1 t1, data2 t2) (data App) {
        ret this
    }

    fun C(x Int) (y Int) {
        ret x + this._b
    }

    fun D() (x Int) {
        ret 3
    }

    fun E() {}
}

typ Result(Data Str = "")

typ Test_package_template[t class](data t) {
    fun Generic(a t) {}
}

typ Test_protocol_template[t class] {
    fun Test[h class](i h)
    fun Test(i t)
}

typ Test_implement_template() {
    Test_protocol_template[Test_implement_template]
    
    fun Test[h class](i h) {}
    fun Test(i Test_implement_template) {}
}

typ Program(`get, set`name Str = "", running Bool = false)

typ Protocol {
    fun C(x Int) (y Int)
    fun D() (y Int) 
    fun E()
}

`"SQL ORM", Table("test")`
typ Test_annotation(
    `Key, Column("id")`
    id Str,
    `Column("nick_name")`
    nick_name Str,
    `Column("profile")`
    profile Str
)

Test_enum := $Ok or Err{}

typ Package(x Int = 1, y Int = 2) { me ->
    fun ParentFunc() {
        me.x = 21
        Print("package")
    }
}
typ Package(y Int->$me) {
    me.x = Const_data
    me.y = y
}

typ Package_child(x Int, y Int->$)(y) {
    this.x = x
}
typ Package_child() { me, super ->
    Package

    fun .ParentFunc() {
        x = 64
        Print("package child")
    }
}